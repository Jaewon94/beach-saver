# 2-1 시스템 아키텍처 설계서

## 1. 개요 (Introduction)

### 1.1. 문서 목적

- 본 문서는 Beach-Saver 시스템의 전반적인 기술 아키텍처를 정의하고 설명하는 것을 목적으로 합니다.
- 주요 컴포넌트, 이들 간의 상호작용, 사용 기술, 배포 전략 및 핵심 품질 속성(확장성, 보안, 성능 등)을 명시하여, 시스템 개발 및 운영의 기술적 청사진을 제공합니다.
- 본 문서의 대상 독자는 프로젝트 관리자, 개발팀, 운영팀 및 기타 기술 관련 이해관계자입니다.

### 1.2. 시스템 개요 (Project Overview 참조)

- Beach-Saver는 부산 해안을 대상으로 GPS 및 모바일 데이터 수집을 활용해 해양쓰레기를 효율적으로 수거하고, 수집된 빅데이터를 기반으로 효과적인 관리 방안 및 정책 제안을 목표로 하는 환경 관리 플랫폼입니다.
- 주요 사용자는 PlatformAdmin, CityAdmin, DistrictAdmin 등의 관리자와 현장 작업자(조사자, 청소자, 수거자), 그리고 시민(자원봉사자)으로 구성됩니다.
- 관리자는 웹(Next.js)을 통해, 작업자는 모바일 앱(React Native)을 통해 시스템에 접근하며, 현재는 부산시에서 시범 운영 중이나 전국 단위 확장을 목표로 설계되었습니다.
- (상세 내용은 "1-1 프로젝트 개요" 문서 참조)

### 1.3. 용어 정의

- **PlatformAdmin:** 플랫폼 전체 운영 및 최고 관리자.
- **CityAdmin:** 시/도 단위 관리자 (예: 부산시청).
- **DistrictAdmin:** 구/군 단위 관리자 (예: 해운대구청).
- **조사자 (Investigator):** 해양 쓰레기 현황을 조사하고 보고하는 작업자.
- **청소자 (Cleaner):** 해양 쓰레기를 청소하고 보고하는 작업자 (정규 또는 시민).
- **수거자 (Collector):** 집하된 쓰레기를 수거하고 보고하는 작업자.
- **시민 (Citizen):** 자원봉사자로 가입하여 청소 활동에 참여하는 일반 사용자.
- **수거용 보고서:** 청소자가 청소 후 쓰레기를 모아둔 집하장의 정보를 기록하는 보고서.
- **Claim 정책:** 특정 업무에 대한 담당자를 지정하여 중복 작업을 방지하는 정책.
- **FR (Functional Requirement):** 기능 요구사항.
- **NFR (Non-Functional Requirement):** 비기능 요구사항.
- **UC (Use Case):** 유스케이스.
- **React Native:** 모바일 앱 개발 프레임워크.
- **Next.js:** 관리자 웹 프론트엔드 개발 프레임워크.
- **Spring Boot:** 백엔드 API 서버 개발 프레임워크.
- **JPA (Java Persistence API):** 자바 ORM 기술 표준.
- **RDS (Relational Database Service):** AWS의 관계형 데이터베이스 서비스.
- **Docker:** 컨테이너 기반 가상화 플랫폼.
- **PWA (Progressive Web App):** 프로그레시브 웹 앱 (본 프로젝트에서는 도입하지 않음).
- **PII (Personally Identifiable Information):** 개인식별정보.

## 2. 아키텍처 목표 및 제약 조건 (Architectural Goals and Constraints)

### 2.1. 주요 아키텍처 드라이버 (Key Architectural Drivers)

- **확장성 (Scalability):** 부산시 시범 운영을 시작으로 전국 단위(다수 지자체)로 서비스를 안정적으로 확장할 수 있는 구조. (NFR-10)
- **사용 편의성 (Usability):** IT 기기 사용에 미숙한 고령층 작업자 및 일반 시민도 쉽게 사용할 수 있는 직관적인 UI/UX 제공. (NFR-3)
- **안정성 및 신뢰성 (Reliability & Availability):** 주요 서비스의 높은 가용성(예: 월 99.9%) 및 데이터 무결성 보장. (NFR-7)
- **보안 (Security):** 개인정보 및 주요 데이터의 안전한 보호, 역할 기반의 엄격한 접근 제어. (NFR-2)
- **유지보수성 (Maintainability):** 명확한 모듈 분리, 표준 기술 사용, 자동화된 문서 및 테스트를 통해 시스템 유지보수 용이성 확보. (NFR-5, NFR-10)
- **성능 (Performance):** 다수 사용자 환경에서도 주요 기능(보고서 처리, 통계 조회 등)의 적절한 응답 속도 보장. (NFR-9)
- **비용 효율성 (Cost-Effectiveness):** 초기에는 저비용 인프라에서 운영 가능하며, 서비스 확장 시 유연하게 대응 가능한 구조.

### 2.2. 기술적 제약 조건 (Technical Constraints)

- 작업자용 모바일 앱은 **React Native**로 개발.
- 관리자용 웹 애플리케이션은 **Next.js**로 개발.
- 백엔드 API 서버는 **Java/Kotlin, Spring Boot, JPA** 활용.
- 데이터베이스는 **RDS (MySQL 호환)** 사용.
- 모든 서비스는 **Docker 컨테이너** 기반으로 패키징 및 배포.
- **PWA(Progressive Web App)는 도입하지 않음** (역할별 앱/웹 완전 분리 원칙 준수).
- 로그인 방식은 일반 사용자 대상 **휴대폰 번호 + 인증번호** 우선 적용.
- 오프라인 환경에서의 작업자 데이터 임시 저장 및 동기화 기능 필수 지원.

## 3. 시스템 아키텍처 (System Architecture)

### 3.1. 아키텍처 개요 (High-Level Architecture)

#### [C4 컨텍스트 다이어그램 예시]

- [실제 다이어그램: docs/2-설계/2-1-시스템아키텍처-context.png]
- 주요 Actor: 관리자(웹), 작업자(앱), 시민(앱), 외부 알림/AI 서비스
- 주요 시스템: 관리자 웹(Next.js), 작업자 앱(React Native), 백엔드 API(SB), DB(RDS), 파일저장소(S3), 알림/AI 외부 서비스

Beach-Saver 시스템은 크게 다음과 같은 주요 서브 시스템으로 구성됩니다:

- **모바일 애플리케이션 (React Native - 작업자/시민용)**
  - **인증/계정 모듈:** 로그인(휴대폰+인증번호), 역할 선택, 자동 로그인, 회원가입(시민)
  - **보고서 관리 모듈:** 조사/청소/수거용 보고서 작성, 사진/GPS 첨부, 임시 저장, 제출
  - **업무 관리 모듈:** 배정된 업무 확인, 업무 상태 업데이트, (팀장) 팀 기여 관리
  - **나의 정보/실적 모듈:** 개인 정보 수정(닉네임 등), 활동 실적/정산 내역 조회
  - **지도/위치 서비스 연동 모듈:** GPS 기반 위치 기록, 지도 표시
  - **오프라인 데이터 동기화 모듈:** 네트워크 불안정 시 데이터 임시 저장 및 자동/수동 동기화
  - **알림 수신 모듈:** 푸시 알림 수신 및 표시, 알림 목록 조회
  - **접근성 지원 모듈:** 큰글씨/고대비 모드
  - **주요 기술스택:** React Native, Zustand, React Navigation, Axios, react-native-image-picker, FCM, react-native-accessibility
- **관리자 웹 애플리케이션 (Next.js - 관리자용)**
  - **인증/계정 관리 모듈:** 관리자 로그인(ID/PW, 2FA), 역할 기반 메뉴 접근
  - **사용자 관리 모듈:** 작업자/시민/관리자 계정 생성(엑셀 대량 등록 포함)/조회/수정/삭제, 권한 관리, 승인 처리
  - **업무 관리 모듈:** 작업 생성/배정/모니터링, 팀 구성/관리, 보고서 검토/승인/반려
  - **통계/대시보드 모듈:** 다양한 조건별 통계 데이터 시각화(차트/지도), 데이터 엑셀 다운로드
  - **정책 관리 모듈 (PlatformAdmin용):** 시스템 운영 정책(알림, 자동화 규칙 등) 설정 및 변경
  - **감사 로그 조회 모듈:** 주요 시스템 이벤트 및 사용자 활동 로그 조회
  - **접근성 지원 모듈:** 큰글씨/고대비 모드
  - **주요 기술스택:** Next.js, React Query, Material UI, Recharts, Axios
- **백엔드 API 서버 (Spring Boot)**
  - **API Gateway (선택적 도입 고려):** 인증, 라우팅, 로드밸런싱, API 키 관리 등
  - **사용자/인증 서비스:** 사용자 정보 관리, 회원가입, 로그인/인증(JWT/OAuth2), 권한 부여
  - **보고서 관리 서비스:** 조사/청소/수거용/수거완료 보고서 CRUD, 상태 관리, 데이터 검증
  - **업무/팀 관리 서비스:** 작업 배정, 팀 관리, Claim 정책 처리, 실적 집계 로직
  - **통계/분석 서비스:** 데이터 집계, 통계 생성, 분석 로직
  - **알림 서비스:** 다양한 채널(푸시, SMS, 이메일)을 통한 알림 발송 로직 및 이력 관리
  - **파일 관리 서비스:** 보고서 첨부 사진 등 파일 업로드/다운로드/저장(S3 연동 등)
  - **(선택적) AI 연동 서비스:** AI 예측 모델, 사진 분석 모델과의 인터페이스
  - **주요 기술스택:** Spring Boot(Java 17), JPA(Hibernate), Spring Security+JWT, AWS S3 SDK, FCM, Twilio, SMTP, Spring RestDocs, JUnit5, Mockito
- **데이터베이스 (RDS - MySQL)**
  - 주요 스키마: 사용자(계정, 역할, 권한), 조직(시청, 구청), 작업자, 팀, 보고서(종류별), 집하장, 알림, 로그(감사, 시스템) 등. (상세 내용은 "2-2 DB 설계서"에서 정의)
- **알림 서비스 (Notification Service)**
  - 내부 알림 생성 모듈 및 외부 푸시(FCM/APNS), SMS 게이트웨이, 이메일(SMTP) 연동 컴포넌트.
- **(선택적) AI 모듈/서비스**
  - 데이터 분석/예측 모델, 이미지 분석 모델 등. (자체 개발 또는 외부 API 활용)

### 3.2. 계층별 아키텍처 (Layered Architecture - 선택 사항)

본 시스템의 백엔드 API 서버는 유지보수성 및 확장성을 고려하여 다음과 같은 논리적 계층 구조를 따를 수 있습니다:

- **Presentation Layer (Controller/API Layer):** 외부 요청(HTTP API)을 수신하고 응답을 반환. 입력값 검증 및 DTO 변환 담당.
- **Application Layer (Service Layer):** 핵심 비즈니스 로직 및 유스케이스 처리. 트랜잭션 관리.
- **Domain Layer:** 도메인 모델(Entities), 값 객체(Value Objects), 도메인 서비스 등 비즈니스 규칙 및 핵심 로직 포함.
- **Infrastructure Layer:** 데이터베이스 연동(JPA Repositories), 외부 서비스 호출, 메시징 등 기술적인 부분 담당.

### 3.3. 주요 컴포넌트 및 모듈 (Key Components and Modules)

#### [컴포넌트 다이어그램 예시]

- [실제 다이어그램: docs/2-설계/2-1-시스템아키텍처-component.png]
- 주요 컨테이너/모듈: 모바일 앱(인증, 보고서, 동기화 등), 관리자 웹(계정, 통계, 정책 등), 백엔드(인증, 보고서, 알림, 파일 등)
- 각 컨테이너/모듈 간 인터페이스 및 데이터 흐름을 시각적으로 표현

Beach-Saver 시스템은 크게 다음과 같은 주요 서브 시스템으로 구성됩니다:

- **모바일 애플리케이션 (React Native - 작업자/시민용)**
  - **인증/계정 모듈:** 로그인(휴대폰+인증번호), 역할 선택, 자동 로그인, 회원가입(시민)
  - **보고서 관리 모듈:** 조사/청소/수거용 보고서 작성, 사진/GPS 첨부, 임시 저장, 제출
  - **업무 관리 모듈:** 배정된 업무 확인, 업무 상태 업데이트, (팀장) 팀 기여 관리
  - **나의 정보/실적 모듈:** 개인 정보 수정(닉네임 등), 활동 실적/정산 내역 조회
  - **지도/위치 서비스 연동 모듈:** GPS 기반 위치 기록, 지도 표시
  - **오프라인 데이터 동기화 모듈:** 네트워크 불안정 시 데이터 임시 저장 및 자동/수동 동기화
  - **알림 수신 모듈:** 푸시 알림 수신 및 표시, 알림 목록 조회
  - **접근성 지원 모듈:** 큰글씨/고대비 모드
  - **주요 기술스택:** React Native, Zustand, React Navigation, Axios, react-native-image-picker, FCM, react-native-accessibility
- **관리자 웹 애플리케이션 (Next.js - 관리자용)**
  - **인증/계정 관리 모듈:** 관리자 로그인(ID/PW, 2FA), 역할 기반 메뉴 접근
  - **사용자 관리 모듈:** 작업자/시민/관리자 계정 생성(엑셀 대량 등록 포함)/조회/수정/삭제, 권한 관리, 승인 처리
  - **업무 관리 모듈:** 작업 생성/배정/모니터링, 팀 구성/관리, 보고서 검토/승인/반려
  - **통계/대시보드 모듈:** 다양한 조건별 통계 데이터 시각화(차트/지도), 데이터 엑셀 다운로드
  - **정책 관리 모듈 (PlatformAdmin용):** 시스템 운영 정책(알림, 자동화 규칙 등) 설정 및 변경
  - **감사 로그 조회 모듈:** 주요 시스템 이벤트 및 사용자 활동 로그 조회
  - **접근성 지원 모듈:** 큰글씨/고대비 모드
  - **주요 기술스택:** Next.js, React Query, Material UI, Recharts, Axios
- **백엔드 API 서버 (Spring Boot)**
  - **API Gateway (선택적 도입 고려):** 인증, 라우팅, 로드밸런싱, API 키 관리 등
  - **사용자/인증 서비스:** 사용자 정보 관리, 회원가입, 로그인/인증(JWT/OAuth2), 권한 부여
  - **보고서 관리 서비스:** 조사/청소/수거용/수거완료 보고서 CRUD, 상태 관리, 데이터 검증
  - **업무/팀 관리 서비스:** 작업 배정, 팀 관리, Claim 정책 처리, 실적 집계 로직
  - **통계/분석 서비스:** 데이터 집계, 통계 생성, 분석 로직
  - **알림 서비스:** 다양한 채널(푸시, SMS, 이메일)을 통한 알림 발송 로직 및 이력 관리
  - **파일 관리 서비스:** 보고서 첨부 사진 등 파일 업로드/다운로드/저장(S3 연동 등)
  - **(선택적) AI 연동 서비스:** AI 예측 모델, 사진 분석 모델과의 인터페이스
  - **주요 기술스택:** Spring Boot(Java 17), JPA(Hibernate), Spring Security+JWT, AWS S3 SDK, FCM, Twilio, SMTP, Spring RestDocs, JUnit5, Mockito
- **데이터베이스 (RDS - MySQL)**
  - 주요 스키마: 사용자(계정, 역할, 권한), 조직(시청, 구청), 작업자, 팀, 보고서(종류별), 집하장, 알림, 로그(감사, 시스템) 등. (상세 내용은 "2-2 DB 설계서"에서 정의)
- **알림 서비스 (Notification Service)**
  - 내부 알림 생성 모듈 및 외부 푸시(FCM/APNS), SMS 게이트웨이, 이메일(SMTP) 연동 컴포넌트.
- **(선택적) AI 모듈/서비스**
  - 데이터 분석/예측 모델, 이미지 분석 모델 등. (자체 개발 또는 외부 API 활용)

### 3.4. 인터페이스 정의 (Interface Definitions)

- **모바일 앱 ↔ 백엔드 API 서버:** RESTful API (HTTPS, JSON 기반). (상세 내용은 "2-3 API 명세서"에서 정의)
- **관리자 웹 ↔ 백엔드 API 서버:** RESTful API (HTTPS, JSON 기반). (상세 내용은 "2-3 API 명세서"에서 정의)
- **(필요시) 백엔드 API 서버 ↔ 외부 서비스 (AI, 지도, 알림 게이트웨이 등):** 각 서비스 제공자의 API 규격 따름.

## 4. 데이터 아키텍처 (Data Architecture)

### 4.1. 데이터 흐름 (Data Flow)

#### [DFD(데이터 흐름도) 예시]

- [실제 다이어그램: docs/2-설계/2-1-시스템아키텍처-dfd.png]
- 주요 프로세스: 보고서 제출, 회원가입/승인, 통계 생성 등
- 데이터 저장소/외부 시스템과의 데이터 이동을 시각적으로 표현

- **작업자 보고서 제출 흐름:** 모바일 앱 (데이터 입력/사진 촬영) → (오프라인 임시 저장) → 백엔드 API 서버 (유효성 검증, 데이터 처리) → 데이터베이스 (저장) → (필요시) 관리자 웹 (조회), 알림 서비스 (관련자 알림).
- **시민 회원가입 및 승인 흐름:** 모바일 앱/웹 (가입 신청) → 백엔드 API 서버 (임시 계정 생성) → 데이터베이스 (저장) → CityAdmin (관리자 웹에서 조회 및 승인) → 백엔드 API 서버 (계정 상태 변경) → 데이터베이스 (업데이트) → 알림 서비스 (시민에게 승인 알림).
- **통계 데이터 생성 흐름:** 데이터베이스 (원본 데이터) → 백엔드 API 서버 (스케줄러 또는 요청 기반 집계/분석 로직 실행) → (필요시 임시 저장 또는 별도 통계 DB) → 관리자 웹 (통계/대시보드 조회).

### 4.2. 데이터 저장소 (Data Storage)

- **주 데이터베이스:** AWS RDS (MySQL 호환) - 사용자 정보, 보고서 데이터, 팀 정보, 업무 정보, 로그 등 정형 데이터 저장.
- **파일 저장소:** AWS S3 (또는 유사 서비스) - 보고서 첨부 사진, 생성된 PDF 보고서 등 대용량 바이너리 파일 저장.
- **(선택적) 캐시 저장소:** Redis (또는 유사 서비스) - 자주 조회되지만 변경 빈도가 낮은 데이터(예: 지역 코드, 공지사항 등) 캐싱, 세션 관리 등에 활용 가능.
- **(선택적) 검색 엔진:** Elasticsearch (또는 유사 서비스) - 대규모 텍스트 데이터(보고서 내용 등)의 빠른 검색 기능 제공 시 고려.

### 4.3. 데이터 보안 및 개인정보보호

- **개인정보(PII) 처리:** 수집 최소화 원칙, 사용자 닉네임 기반 ID 자동 생성 (PII 미포함), 실명 등 PII는 별도 안전하게 저장 및 접근 통제. ("Beach-Saver 문서화 개요" 계정 정책 참조)
- **데이터 암호화:**
  - 전송 중 데이터: 모든 외부 통신 HTTPS/TLS 적용.
  - 저장 데이터: 주요 개인정보 및 민감 정보는 데이터베이스 레벨 또는 애플리케이션 레벨에서 AES256 등 강력한 알고리즘으로 암호화. (NFR-2)
- **접근 제어:** 역할 기반 접근 제어(RBAC)를 통해 데이터 접근 권한 최소화. (NFR-2, FR-1, FR-12, FR-15)
- **데이터 백업 및 복구:** RDS 자동 백업 기능 활용, 정기적 백업(일별/주별) 및 특정 시점 복구(PITR) 정책 수립. S3 파일 버전 관리 및 백업. (NFR-11)
- **감사 로그:** 모든 데이터 접근, 생성, 수정, 삭제 이력 상세 기록. (FR-1)

## 5. 기술 스택 (Technology Stack)

### 모바일 애플리케이션 (작업자/시민용)

- **프레임워크:** React Native
- **상태 관리:** Redux Toolkit (대규모/복잡한 상태 관리에 표준, 커뮤니티/자료 풍부)
  - (대안) Zustand: 단순/경량 앱에 적합, 러닝커브 낮음
- **네비게이션:** React Navigation (React Native 표준, 생태계 최대)
- **API 통신:** Axios (Promise 기반, 인터셉터/에러처리 등 Fetch 대비 실전 기능 우수)
- **스타일링:** Styled Components (동적 스타일링/컴포넌트화에 강점) 또는 React Native StyleSheet (성능/기본 제공)
- **오프라인 저장소:** @react-native-async-storage/async-storage (Key-Value 임시저장)
- **권한 관리:** react-native-permissions (GPS/카메라 등 기기 권한)
- **푸시 알림:** react-native-firebase (FCM 연동, 실무 표준) 또는 react-native-push-notification
- **날짜/시간 처리:** date-fns (경량/모듈화)

### 관리자 웹 애플리케이션 (관리자용)

- **프레임워크:** Next.js (React 기반)
- **상태 관리:** TanStack Query(React Query) (서버 상태 관리 표준, 캐싱/동기화/페칭)
  - (대안) Zustand, Recoil: 클라이언트 전역 상태 필요시 경량/간단
  - (대안) Redux Toolkit: 복잡한 상태/대규모 프로젝트
- **UI 라이브러리:** Ant Design (기업/관리자 대시보드 실전 표준, 컴포넌트 다양)
  - (대안) Material UI(MUI): 구글 스타일, 커스텀 용이
  - (대안) Tailwind CSS: 유틸리티 기반, 자유도↑(컴포넌트 직접구성 필요)
- **API 통신:** Axios
- **차트 라이브러리:** Recharts (컴포넌트 기반, 실무 표준)
  - (대안) Chart.js: 간단/유연, 다양한 차트 지원
- **폼 관리:** React Hook Form (성능/사용성 우수)
- **날짜/시간 처리:** date-fns
- **국제화(i18n):** next-i18next (Next.js 공식/실무 표준)

### 백엔드 API 서버

- **언어:** Java / Kotlin (Spring Boot)
- **프레임워크:** Spring Boot, Spring MVC/WebFlux, Spring Data JPA, Spring Security
- **ORM:** JPA (Hibernate)
- **DB 커넥션 풀:** HikariCP (Spring Boot 2.x+ 기본, 성능/안정성 우수)
- **API 인증/인가:** OAuth 2.0, JWT
- **유효성 검증:** Spring Boot Starter Validation (Hibernate Validator)
- **로깅:** SLF4j + Logback (Spring Boot 기본)
- **테스트:** JUnit 5, Mockito (Spring Boot Test)
- **기타 주요 라이브러리:**
  - Lombok (보일러플레이트 최소화)
  - MapStruct (DTO-Entity 매핑 자동화)
- **API 문서화:** Spring RestDocs (테스트 기반, 코드-문서 일치)
  - (대안) Swagger(OpenAPI): 어노테이션 기반, UI 제공

### 데이터베이스

- **AWS RDS (MySQL 호환)**

### 파일 저장소

- **AWS S3**

### 인프라 및 배포

- **컨테이너화:** Docker, Docker Compose
- **클라우드 플랫폼:** AWS (ECS, Fargate, EC2, Lightsail 등)
- **CI/CD:** GitHub Actions

### 협업 도구

- **소스 코드 관리:** Git, GitHub 또는 GitLab
- **프로젝트 관리/이슈 트래킹:** Jira
- **문서 협업:** Confluence 또는 Notion
- **커뮤니케이션:** Slack 또는 Microsoft Teams

## 6. 배포 아키텍처 (Deployment Architecture)

### [배포 아키텍처 요약]

- VPC
  - Public Subnet: ALB, Bastion
  - Private Subnet: ECS(Backend), RDS, Redis
- ALB → ECS(Backend) → RDS/Redis/S3
- Next.js(SSR): ECS or Vercel/Amplify
- S3+CloudFront: 정적 웹/이미지
- FCM/SMS/Email: 외부 서비스 연동
- CloudWatch/Prometheus: 모니터링/알림

### 6.1. 배포 환경 (Deployment Environment)

- **개발(Development) 환경:** 개발자 로컬 환경 또는 공유 개발 서버. Docker Compose 활용하여 유사 운영 환경 구성.
- **스테이징(Staging) 환경:** 운영 환경과 거의 동일한 구성으로, 배포 전 최종 테스트 및 검증 수행.
- **운영(Production) 환경:** 실제 서비스 제공 환경. 고가용성 및 안정성 확보.

### 6.2. 배포 시나리오 (Deployment Scenarios)

#### [배포 다이어그램 예시]

- [실제 다이어그램: docs/2-설계/2-1-시스템아키텍처-deploy.png]
- AWS VPC, Subnet, ALB, ECS, RDS, S3, CloudFront 등 실제 배포 구조를 시각적으로 표현

- **초기 배포 (저비용 옵션):**
  - 단일 서버(온프레미스 또는 저가 VPS)에 Docker Compose를 사용하여 백엔드 API 서버, (필요시) 관리자 웹 프론트엔드(SSR), 데이터베이스 컨테이너 배포.
  - 모바일 앱은 각 앱 스토어 통해 배포.
  - 관리자 웹 프론트엔드는 정적 호스팅(S3+CloudFront 또는 Netlify/Vercel 등)과 백엔드 API 연동 방식도 고려.
- **AWS 기반 확장 배포 (예시):**
  - **모바일 앱 (React Native):** App Store, Google Play Store 통해 배포.
  - **관리자 웹 (Next.js):** AWS Amplify, Vercel, Netlify 또는 S3+CloudFront (정적 빌드) / EC2 또는 ECS/Fargate (SSR) 등에 배포.
  - **백엔드 API 서버 (Spring Boot):** Docker 이미지를 AWS ECS/Fargate 또는 EC2 (Auto Scaling Group)에 배포. Application Load Balancer(ALB) 사용.
  - **데이터베이스:** AWS RDS for MySQL 사용 (다중 AZ 구성으로 고가용성).
  - **파일 저장소:** AWS S3 사용.
  - **(선택적) API Gateway:** Amazon API Gateway 사용.
  - **(선택적) CDN:** Amazon CloudFront 사용 (웹 정적 콘텐츠 및 API 응답 캐싱).
- **CI/CD 파이프라인:** GitHub Actions를 사용하여 코드 푸시 시 자동 빌드, 테스트, Docker 이미지 생성 및 각 환경(개발/스테이징/운영)으로의 배포 자동화.

## 7. 품질 속성/운영 이슈/엣지케이스

| 구분        | 주요 이슈/엣지케이스                | 대응 전략/실무 처리                                                     |
| ----------- | ----------------------------------- | ----------------------------------------------------------------------- |
| 오프라인    | 앱 네트워크 불안정, 임시저장/동기화 | 로컬DB/IndexedDB, 재시도/충돌해결 로직                                  |
| 대량 알림   | 푸시/SMS/이메일 지연/실패           | 비동기 큐, 실패시 재전송, 이력/모니터링                                 |
| 데이터 충돌 | 동시 보고/수정, 중복 Claim          | 서버단 Lock, 중복검증, 사용자 경고/차단                                 |
| 장애/복구   | DB/서버 장애, 데이터 유실           | RDS Multi-AZ, S3 버전관리, 자동백업/복구                                |
| 보안        | 인증우회, 권한상승, PII 노출        | RBAC, 2FA, 암호화, 접근로그, 취약점 점검                                |
| 성능        | 대용량 통계/검색, 실시간 지도       | 인덱스, 캐시, 비동기, 검색엔진(ES)                                      |
| 확장성      | 전국 확장, 조직별 데이터 분리       | DB 샤딩, 멀티테넌시(스키마 분리, 테넌트 ID 컬럼 등), 조직코드 기반 분리 |

## 8. 아키텍처 결정 사항 및 근거 (Architectural Decisions and Rationale)

| 결정 사항                | 근거/대안/주의점                                   |
| ------------------------ | -------------------------------------------------- |
| RN/Next.js/SB/JPA/Docker | 크로스플랫폼, 생산성, 커뮤니티, 유지보수성         |
| 역할별 계정 분리         | 보안/감사/책임 명확화, 통합계정은 실무상 위험      |
| 오프라인 지원            | 현장 환경 필수, 임시저장/동기화 충돌 주의          |
| 대량 알림/통계/지도      | 비동기/캐시/검색엔진, 실시간성-정확성 트레이드오프 |
| 전국 확장(멀티테넌시)    | 조직코드/DB샤딩, 데이터 분리정책, 운영 자동화 필요 |
| 장애/복구/모니터링       | AWS 관리형, 자동화, 실시간 알림, 정기 점검         |
| 보안(PII/권한/로그)      | 암호화, RBAC, 접근로그, 정기 취약점 점검           |

## 9. 문서 내 참고/링크

- [C4 컨텍스트 다이어그램: docs/2-설계/2-1-시스템아키텍처-context.png]
- [컴포넌트 다이어그램: docs/2-설계/2-1-시스템아키텍처-component.png]
- [DFD(데이터 흐름도): docs/2-설계/2-1-시스템아키텍처-dfd.png]
- [배포 다이어그램: docs/2-설계/2-1-시스템아키텍처-deploy.png]
- [ERD: docs/2-설계/2-2-DB설계.md]
- [API 명세: docs/2-설계/2-3-API명세서.md]
- [테스트/운영: docs/3-운영/3-1-테스트전략.md, 3-2-운영가이드.md]

---

이 뼈대를 시작으로 각 섹션의 `[사용자 입력 필요]` 또는 `[TODO]` 부분을 채워나가시면 됩니다. 특히 **3. 시스템 아키텍처** 섹션의 다이어그램과 **6. 배포 아키텍처**의 다이어그램은 전체 구조를 이해하는 데 매우 중요하므로, 도구를 사용하여 시각적으로 표현해주시는 것이 좋습니다.

작성하시면서 특정 기술 결정에 대한 논의나 다이어그램 표현 방식 등에 대해 궁금한 점이 있으시면 언제든지 다시 질문해주세요!

> **상위 정책/정의/표/다이어그램은 반드시 [[README]] 및 [[1-1-프로젝트개요]]를 참조할 것.**
